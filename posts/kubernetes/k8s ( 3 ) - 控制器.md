```
{
    "url": "k8s-controller",
    "time": "2020/09/12 12:08",
    "tag": "Kubernetes,容器化"
}
```

# 一、概述

我们在前面概念章节提到了控制器以及常用控制器的职责。所谓可控制器就是用来控制维持`Pod`的状态和行为，不过控制器并不都是同级别的，比如`Deployment`管理`ReplicaSet`，`HPA`可以对`RS`、`Deployment`设置扩容方案，但终归目的是用来控制`Pod`。

| 编号 | 控制器                                | 说明                                                         | 应用场景   |
| ---- | ------------------------------------- | ------------------------------------------------------------ | ---------- |
| 1    | Deployment                            | 部署无状态应用                                               | Web应用    |
| 2    | StatefulSet                           | 部署有状态应用                                               | 数据库     |
| 3    | DaemonSet                             | 在每一个Node上面运行一个Pod；新加入的Node也同样会自动运行一个Pod | Agent      |
| 4    | Job/CronJob                           | 一次性任务/周期任务                                          | 脚本、备份 |
| 5    | ReplicaSet<br />ReplicationController | 控制容器应用的副本数量，                                     |            |
| 6    | Horizontal Pod Autoscaling            | Pod水平自动缩放                                              |            |

Pod可以分为两类，一类是直接创建的Pod，没有管理者，退出后不会有重新拉起操作。另一类就是控制器控制的Pod，可以根据控制器的不同规则对Pod做不同的行为控制。

概念在前面章节已经提到，所以本章节主要从示例维度来对控制器进行说明。

# 二、RS / RC

`ReplicaSet`/`ReplicationController` 确保系统中的Pod数量永远等于设置的个数。

在新版的`Kubernetes`中建议使用`ReplicaSet (RS)`来取代`ReplicationController(RC)`。`ReplicaSet`跟`ReplicationController`没有本质的不同，只是名字不一样，但`ReplicaSet`支持集合式`selector`，k8s里通过对资源对象打标签，然后可以按不同的规则来筛选这些标签。具体的用法在前一篇`Label / Selector`中有说到，到具体的差异可以从描述文档上看到：

```
$ kubectl explain rc.spec
KIND:     ReplicationController
VERSION:  v1

FIELDS:
   selector	<map[string]string>


$ kubectl explain rs.spec
KIND:     ReplicaSet
VERSION:  apps/v1

FIELDS:
   selector	<Object> -required-

$ kubectl explain rs.spec.selector
KIND:     ReplicaSet
VERSION:  apps/v1

FIELDS:
   matchExpressions	<[]Object>
     matchExpressions is a list of label selector requirements. The requirements
     are ANDed.

   matchLabels	<map[string]string>
     matchLabels is a map of {key,value} pairs. A single {key,value} in the
     matchLabels map is equivalent to an element of matchExpressions, whose key
     field is "key", the operator is "In", and the values array contains only
     "value". The requirements are ANDed.
```

对比它俩的文档，可以看到结果略有差异，RC的的selector是一个map，而RS的selector为一个object，必填，下面有两个key: matchExpressions、matchLabels。而`matchExpressions`支持的筛选规则似乎更灵活些，就是上面说到的集合式`selector`。

```
apiVersion: v1
kind: ReplicationController
metadata:
  name: myapp
spec:
  selector:
      app: myapp



apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: myapp
spec:
  selector:
    matchLabels:
      app: myapp
    matchExpressions；
      - {key: tier, operator: In, values: [frontend]}
      - {key: environment, operator: NotIn, values: [dev]}
```

# 三、Deployment

## 3.1 Deployment 与 RS

定义`Deployment`会创建`Pod`和`ReplicaSet`，创建关系大致是`Deployment`创建`ReplicaSet`，`ReplicaSet`创建`Pod`。文档上对它俩的描述：

- ReplicaSet ensures that a specified number of pod replicas are running at any given time.
- Deployment enables declarative updates for Pods and ReplicaSets.

`Deployment`不直接管理`Pod`，而是通过`ReplicaSet`来进行管理，他们的功能差不多，都支持自动扩容、缩容，但`Deployment`支持滚动更新和回滚，这个是`ReplicaSet`不支持的，所以一般建议是通过`Deployment`来管理`Pod`。

**先来看看ReplicaSet的定义：**

```
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: rsname
spec:
  replicas: 1
  selector:
    matchLabels:
      name: rspod
  template:
    metadata:
      labels: 
        name: rspod
    spec:
      containers: 
      - name: nginx
        image: nginx:1.19.2-alpine
        resources:
          limits:
            memory: "128Mi"
            cpu: "500m"
        ports:
        - containerPort: 80


$ kubectl apply -f rs-nginx.yaml
replicaset.apps/rsname created

$ kubectl scale rs rsname --replicas=2
```

可以看到`ReplicaSet`的定义和`Deployment`定义是一样的，而且也支持扩容。

## 3.2 Deployment 滚动更新

我们先来创建个Nginx的Deployment，可能是本地的网络原因，指定type为LoadBalancer本机端口才能访问到（后续在探究这个问题），所以同时创建了service。

```
apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
  labels:
    project: nginx
spec:
  selector:
    app: nginx-pod
  type: LoadBalancer
  ports:
  - port: 38000
    targetPort: 80
    protocol: TCP

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deploy
  labels:
    project: nginx
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.19.2-alpine
        imagePullPolicy: IfNotPresent
        resources:
          limits:
            memory: "128Mi"
            cpu: "500m"
        ports:
        - containerPort: 80

```

通过apply创建，并且在最后增加了`--record`，用来记录历史版本号，可以回滚时指定某个版本。

> --record=false: Record current kubectl command in the resource annotation. If set to false, do not record the
> command. If set to true, record the command. If not set, default to updating the existing annotation value only if one already exists.

```
$ kubectl apply -f nginx.yaml --record
service/nginx-svc created
deployment.apps/nginx-deploy created
```

这个配置前面也配过好几次了，接下来本机就可以访问`http://localhost:38000/`看到`Nginx`的欢迎页。命令行也可以看到deploy、rs、pod信息。

```
$ kubectl get deploy
NAME           READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deploy   2/2     2            2           25s

$ kubectl get rs
NAME                     DESIRED   CURRENT   READY   AGE
nginx-deploy-9bdb559b9   2         2         2       27s

$ kubectl get pod
NAME                           READY   STATUS    RESTARTS   AGE
nginx-deploy-9bdb559b9-hlrjq   1/1     Running   0          28s
nginx-deploy-9bdb559b9-rw2gh   1/1     Running   0          28s
```

### 3.2.1 版本更新

尝试更新nginx镜像到`1.18.0-alpine`版本。更新方式通资源清单中所讲，可以通过更新yaml文件，或者通过`set image`命令操作就会触发rollout。

```
$ kubectl set image deployment nginx-deploy nginx=nginx:1.18.0-alpine
```

再次查看资源信息，可以看到增加了一个rs，DESIRED、CURRENT、READY对应为1、1、0，也新增了一个pod，状态是ImagePullBackOff。但这里为啥是期望的DESIRED数量1呢？，猜测这是一个中间状态，跟滚动更新流程有关系，rs先启动一个，启动成功后再扩容一个，但由于第一个现在卡主了，所以看到了这个状态。

```
$ kubectl get deploy
NAME           READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deploy   2/2     1            2           3m8s

$ kubectl get rs
NAME                      DESIRED   CURRENT   READY   AGE
nginx-deploy-6d57fb5cfd   1         1         0       2m9s
nginx-deploy-9bdb559b9    2         2         2       3m11s


$ kubectl get pod
NAME                            READY   STATUS             RESTARTS   AGE
nginx-deploy-6d57fb5cfd-ktw6w   0/1     ImagePullBackOff   0          2m14s
nginx-deploy-9bdb559b9-hlrjq    1/1     Running            0          3m16s
nginx-deploy-9bdb559b9-rw2gh    1/1     Running            0          3m16s
```

查看Pod信息，可以到镜像获取失败。

```
$ kubectl describe pod nginx-deploy-6d57fb5cfd-ktw6w

Events:
  Type     Reason     Age                  From                     Message
  ----     ------     ----                 ----                     -------
  Normal   Scheduled  <unknown>            default-scheduler        Successfully assigned default/nginx-deploy-6d57fb5cfd-ktw6w to docker-desktop
  Warning  Failed     2m58s                kubelet, docker-desktop  Failed to pull image "nginx:1.18.0-alpine": rpc error: code = Unknown desc = Get https://registry-1.docker.io/v2/library/nginx/manifests/1.18.0-alpine: net/http: TLS handshake timeout
  Warning  Failed     2m12s                kubelet, docker-desktop  Failed to pull image "nginx:1.18.0-alpine": rpc error: code = Unknown desc = Get https://registry-1.docker.io/v2/: net/http: TLS handshake timeout
  Warning  Failed     63s                  kubelet, docker-desktop  Failed to pull image "nginx:1.18.0-alpine": rpc error: code = Unknown desc = Get https://registry-1.docker.io/v2/library/nginx/manifests/sha256:8853c7e938c2aa5d9d7439e698f0e700f058df8414a83134a09fcbb68bb0707a: net/http: TLS handshake timeout
  Warning  Failed     63s (x3 over 2m58s)  kubelet, docker-desktop  Error: ErrImagePull
  Normal   BackOff    33s (x4 over 2m58s)  kubelet, docker-desktop  Back-off pulling image "nginx:1.18.0-alpine"
  Warning  Failed     33s (x4 over 2m58s)  kubelet, docker-desktop  Error: ImagePullBackOff
  Normal   Pulling    22s (x4 over 3m37s)  kubelet, docker-desktop  Pulling image "nginx:1.18.0-alpine"
```

查看版本记录，需要前面开启`--record`，可以通过.spec.revisionHistoryLimit指定deployment最多保留多少revision记录。貌似这个版本记录并不太清晰，不同版本之间看不出区别。

```
$ kubectl rollout history deployment nginx-deploy
deployment.apps/nginx-deploy
REVISION  CHANGE-CAUSE
1         kubectl apply --filename=nginx.yaml --record=true
2         kubectl apply --filename=nginx.yaml --record=true
```

### 3.2.2 版本回滚

看起来这一次更新镜像异常，正好可以操作下回滚：

```
$ kubectl rollout undo deployment nginx-deploy
deployment.apps/nginx-deploy rolled back
```

也可以指定某个历史版本

```
$ kubectl rollout undo deployment nginx-deploy --to-revision=1
```

再来查看资源信息，状态已经恢复，Deployment增加了另一个rs用来做滚动升级。

```
$ kubectl get deploy
NAME           READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deploy   2/2     2            2           7m19s
pengbotao:k8s peng$ kubectl get rs
NAME                      DESIRED   CURRENT   READY   AGE
nginx-deploy-6d57fb5cfd   0         0         0       6m19s
nginx-deploy-9bdb559b9    2         2         2       7m21s
pengbotao:k8s peng$ kubectl get pod
NAME                           READY   STATUS    RESTARTS   AGE
nginx-deploy-9bdb559b9-hlrjq   1/1     Running   0          7m26s
nginx-deploy-9bdb559b9-rw2gh   1/1     Running   0          7m26s
```

### 3.2.3 版本更新

我们尝试手动下载镜像，然后再次升级看看。刷`rs`可以看到中间数量的变更。

```
$ kubectl get rs
NAME                      DESIRED   CURRENT   READY   AGE
nginx-deploy-6d57fb5cfd   2         2         1       8h
nginx-deploy-9bdb559b9    1         1         1       8h

$ kubectl get rs
NAME                      DESIRED   CURRENT   READY   AGE
nginx-deploy-6d57fb5cfd   2         2         2       8h
nginx-deploy-9bdb559b9    0         0         0       8h
```

通过`describe`可以看到现在的版本以及日志信息

```
  $ kubectl describe deploy nginx-deploy
  ...
  Pod Template:
  Labels:  app=nginx-pod
  Containers:
   nginx:
    Image:      nginx:1.18.0-alpine

  ...
  
  Events:
  Type    Reason             Age                  From                   Message
  ----    ------             ----                 ----                   -------
  Normal  ScalingReplicaSet  63s (x3 over 8h)     deployment-controller  Scaled up replica set nginx-deploy-6d57fb5cfd to 1
  Normal  ScalingReplicaSet  62s (x2 over 4m23s)  deployment-controller  Scaled down replica set nginx-deploy-9bdb559b9 to 1
  Normal  ScalingReplicaSet  61s (x2 over 4m23s)  deployment-controller  Scaled up replica set nginx-deploy-6d57fb5cfd to 2
  Normal  ScalingReplicaSet  59s (x2 over 4m21s)  deployment-controller  Scaled down replica set nginx-deploy-9bdb559b9 to 0
```

通过Events中`ScalingReplicaSet`看到流程是：

- 升级的1.18版本，启用一个Pod，启动成功后
- 原版本1.19停用一个Pod
- 1.18在启动一个Pod
- 1.19版本Pod都停掉，完成升级。

### 3.2.4 其他更新操作

```
# 暂停
$ kubectl rollout pause deployment nginx-deploy

# 查看状态
$ kubectl rollout status deployment nginx-deploy
deployment "nginx-deploy" successfully rolled out

# 恢复
$ kubectl rollout resume deployment nginx-deploy

# 扩容
$ kubectl scale deployment nginx-deploy --replicas 3

# 删除
$ kubectl delete service,deploy -l project=nginx
```

### 3.2.5 资源清单配置

```
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx-pod
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  minReadySeconds: 5
  template:
```

文档说明：

```
$ kubectl explain deploy.spec.strategy
KIND:     Deployment
VERSION:  apps/v1

RESOURCE: strategy <Object>

DESCRIPTION:
     The deployment strategy to use to replace existing pods with new ones.

     DeploymentStrategy describes how to replace existing pods with new ones.

FIELDS:
   rollingUpdate	<Object>
     Rolling update config params. Present only if DeploymentStrategyType =
     RollingUpdate.

   type	<string>
     Type of deployment. Can be "Recreate" or "RollingUpdate". Default is
     RollingUpdate.
```

# 四、DaemonSet



# 五、Job/CronJob

# 六、StatefulSet

@todo



# 七、HPA

@todo













---

- [1] [Kubernetes学习之路（十二）之Pod控制器--ReplicaSet、Deployment](https://www.cnblogs.com/linuxk/p/9578211.html)

